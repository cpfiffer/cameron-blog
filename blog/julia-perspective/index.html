<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <title>Julia</title> <header> <nav> <a href="/">cameron pfiffer</a> ∘ <a href="/">about</a> ∘ <a href="/blog/">blog</a> ∘ <a href="/links/">links</a> <hr/> </nav> </header> <div class=franklin-content > <p>I have some thoughts on the future of the <a href="https://julialang.org">Julia language</a>, as prompted by <a href="https://twitter.com/yahrMason/status/1772445238730084642">Mason Yahr</a> on X. As many of you all know I&#39;m kind of a fanboy, but I too have noticed kind of a slowdown.</p> <p>So, here&#39;s a few thoughts on the good &#43; the bad.</p> <h2 id=the_good ><a href="#the_good" class=header-anchor >The good</a></h2> <p><strong>Julia is beautiful.</strong> I started writing Julia in maybe 2015 or so. Not sure the version exactly but I think it was at or before 0.5, when the language was very new. I fell in love with the language for a pretty superficial reason to start: it is beautiful. I consider myself proficient in many languages, and few are as beautiful to my eye as Julia is.</p> <p><strong>Julia is a good language.</strong> Once I was hooked on the beauty, I started to appreciate how good a language it is, and how much my brain <em>loves it</em>. Julia can be a functional language if you want. It can be strongly typed, but you can also mostly ignore the types as you go and let the compiler handle it. It&#39;s flexible when you want it to be and structured when you need it. It&#39;s fast, if you write it correctly, and it&#39;s full of so many fun little bells and whistles that I am still constantly learning beautiful new things about the language. <a href="https://docs.julialang.org/en/v1/manual/methods/">Multiple dispatch</a>, dispatching to functions based on the type of the inputs, is a really incredible tool that&#39;s a blast to use. Multiple dispatch is also why the language is composable, meaning that you can pretty easily borrow and mix things together across packages.</p> <p><strong>Julia is powerful as fuck.</strong> You can make some really amazing things in Julia basically by just building up a type system for your problem. The per-line efficiency of the language is really high, meaning that it is easy to compose a few functions that are extremely powerful and flexible. The compiler and the type system do a lot of work for you and can get you from 0 to 100 in a very small amount of code. Go check out my favorite package, <a href="https://github.com/mossr/BeautifulAlgorithms.jl">BeautifulAlgorithms.jl</a>, which implements very dense algorithms.</p> <p>Here&#39;s an example of a dense neural net:</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> LinearAlgebra

<span class=hljs-keyword >function</span> multi_layer_neural_network(x, 𝐖, φ, 𝐠)
    𝐡ᵢ = φ(x)
    <span class=hljs-keyword >for</span> (i,g) <span class=hljs-keyword >in</span> enumerate(𝐠)
        𝐡ᵢ = map(𝐰ⱼ -&gt; g(𝐰ⱼ ⋅ 𝐡ᵢ), 𝐖[i])
    <span class=hljs-keyword >end</span>
    𝐡ᵢ ⋅ last(𝐖)
<span class=hljs-keyword >end</span></code></pre> <p>or, as a one-liner:</p> <pre><code class="julia hljs">neural_network(x, 𝐕, 𝐰, φ, g) = 𝐰 ⋅ map(𝐯ⱼ -&gt; g(𝐯ⱼ ⋅ φ(x)), 𝐕)</code></pre>
<p>Gaussian processes are similarly gorgeous:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Distributions
<span class=hljs-keyword >using</span> LinearAlgebra

<span class=hljs-keyword >struct</span> GaussianProcess
    m::<span class=hljs-built_in >Function</span> <span class=hljs-comment ># mean function</span>
    k::<span class=hljs-built_in >Function</span> <span class=hljs-comment ># covariance function</span>
<span class=hljs-keyword >end</span>

𝛍(X, m) = [m(𝐱) <span class=hljs-keyword >for</span> 𝐱 <span class=hljs-keyword >in</span> X]
𝚺(X, k) = [k(𝐱,𝐱′) <span class=hljs-keyword >for</span> 𝐱 <span class=hljs-keyword >in</span> X, 𝐱′ <span class=hljs-keyword >in</span> X]

<span class=hljs-keyword >function</span> Base.rand(𝒢::GaussianProcess, X, inflation=<span class=hljs-number >1e-6</span>)
    𝒩 = MvNormal(𝛍(X, 𝒢.m), 𝚺(X, 𝒢.k) + inflation*I)
    <span class=hljs-keyword >return</span> rand(𝒩)
<span class=hljs-keyword >end</span></code></pre>
<p>There&#39;s more, but go checkout the repo.</p>
<p><strong>Julia is state-of-the-art for scientific computing.</strong> Julia was, and still mostly is, a scientific computing language. I was one of the rarer Julia users who was not a refugee from scientific computing elsewhere. Most of the users of Julia at that time &#40;from what I remember&#41; were scientists – people who hated matlab and wanted out. Think academics. People who do numerical computing at massive scale and really need the speed. There&#39;s lots of folks who do climate/ocean/physics/etc. in Julia because they can sketch out a model super quickly and get code that is reasonably performant in a fraction of the dev time it would take to write it in C&#43;&#43; or Fortran or whatever.</p>
<p><strong>The package management is world-class.</strong> Julia&#39;s Pkg.jl is based on Rust&#39;s <code>cargo</code>, and it is incredible. I do not worry about reproducible environments, installing packages, etc. It just happens without me thinking about it. No stupid <code>pip</code> nightmares, no managing nightmarish virtual environments, etc. It&#39;s just good shit.</p>
<p><strong>The numerical computing ecosystem is amazing.</strong> The language is still very much like this. Julia&#39;s massive heavy-hitter is <a href="https://sciml.ai">SciML</a>, which is just a monster ecosystem built for hyper-performant differential equations, nonlinear systems, physics-informed neural nets, whatever. It&#39;s a crazy cool world and it&#39;s not clear to me that there&#39;s anything quite like it elsewhere in other languages. There&#39;s other large packages, like <a href="https://turinglang.org/stable/">Turing.jl</a> for probabilistic programming, which is how I got started in large-scale engineering and open source work. If you want scientific computing or dope-ass mathy stuff, I think Julia is still a world-class language with a ton to offer.</p>
<p><strong>The GPU stuff is crazy.</strong> Oh – also, it&#39;s insanely easy to work with GPUs. Seriously. Go try it out if you want to do GPU stuff. It&#39;s a breeze. Most of the stuff you might want to do can be done by just wrapping arrays in GPU types, and it&#39;ll mostly handle the operations for you without you changing anything. Writing kernels is a little harder, as it always is, but there&#39;s lots of cool tools like <a href="https://github.com/JuliaGPU/KernelAbstractions.jl">KernelAbstractions.jl</a> for working across GPU architectures.</p>
<p>It also supports a lot of the functionality you&#39;d need for data work. <a href="https://dataframes.juliadata.org/stable/">DataFrames.jl</a> is really incredible, and we have a lot of very good stuff for working with data sources: csvs, JSON, HDF5, Arrow, Parquet, etc. All of this stuff works pretty well and I no longer notice that I don&#39;t have access to some core component of my typical data workflow.</p>
<p>I actually use a lot of Julia for the backend of <a href="https://www.comind.me">Comind</a>, my side project. It&#39;s my server side and general compute workhorse for all kinds of generative AI stuff. We have an excellent package called <a href="https://github.com/svilupp/PromptingTools.jl">PromptingTools.jl</a> that handles an absurd amount of standard generative AI processes you might want to do, and I have heavily integrated it into the Comind tech stack. Really really wonderful to work with, and the package creator Jan is a delight to talk to.</p>
<p>Overall I would say it&#39;s still very much a growing language. There are lots of wonderful people working on it and making amazing things, and I don&#39;t really see myself leaving the language any time soon.</p>
<h2 id=the_bad ><a href="#the_bad" class=header-anchor >The bad</a></h2>
<p>Okay, so I said a lot of nice things, but I&#39;ll give the critiques I have noticed.</p>
<p><strong>Deep learning is a bit behind</strong>. The deep learning stuff tooling is behind and will take a lot of effort to catch up to the state-of-the-art. Pytorch/Tensorflow have an <strong>absurd</strong> amount of resources behind them that <a href="https://fluxml.ai">Flux.jl</a>, our deep learning toolkit, can&#39;t quite compete with. Admittedly it is <em>really good</em> for how much resources it does have, which is kind of a big endorsement of the contributers of Flux.jl and of the language it is built on. I would actually really love to spend some dev hours on it but ultimately I am very time constrained and have a job.</p>
<p>A few of us are working on drumming up support for Julia-native language model inference. This sort of exists but is scattered across the ecosystem, and hasn&#39;t had a big focused effort to consolidate everything into one spot. It&#39;ll take a bit of work but it&#39;s doable. Some have pointed out that it&#39;s maybe not even worth doing because Python is just going to eat everyone&#39;s lunch forever, but I choose to live in a world where we can make cool shit in a language we love.</p>
<p>A brief aside on the deep learning in Julia problem. One of the massive advantages of Julia is that everything is composable. If you write a package with a few types and functions and then use that package elsewhere, it&#39;s actually pretty damn easy to just link all the functionality of the packages together. I can imagine a world where this composability is going to be very useful in generative AI workflows, where you have many models stacked together. You might want to optimize one or more objective functions, in which case it would be awesome to have gradients that can propogate all the way through the models. In Julia this is easier than in most other languages &#40;but not perfect&#41;, because the autodiff systems are usually at the language level and not statically compiled graphs as in JAX/Tensorflow.</p>
<p><strong>Fringe packages tend to bitrot quicker.</strong> Because a lot of Julia users are academics, they write packages for some very specific purpose and then don&#39;t really maintain it. They have jobs and lives and a lot of these packages just don&#39;t get used that often. There&#39;s not really a lot of financial resources for developers who work in Julia, so most people tend to use Julia because they are trying to achieve a task but are not building something for a money-making entity like a corporation. </p>
<p>In a lot of ways this is fine – most of these packages fall a bit off the map because they are hyper-specialized to some field that studies some arcane manifold-discrete optimization-graph theory concoction that five people on Earth understand. These are awesome and we want these, but there&#39;s kind of a graveyard of little packages all over the place. </p>
<p>The core packages are fine, and tend to have enough support to either maintain the course or grow steadily. This varies from place to place, but the big folks in the ecosystem that are run by academic labs, SciML, JuliaHub, etc. seem to be well cared for.</p>
<p><strong>The community is fractured.</strong> A <em>huge</em> mistake for the language was starting a Slack for the language. A lot of people have great conversations there, and, because paying for a persistent Slack room for the public would cost a bajillion dollars, all of those conversations disappear. There is no persistence of knowledge.</p>
<p>We tried to move everyone to Zulip, but of course many stayed in Slack, and now there&#39;s hardos and nerds in the Zulip. You can always find cool people there. Still, most of the regular community members are in the Slack, where open-source knowledge goes to die. There&#39;s also a Discord channel. Which, I dunno. I don&#39;t use it much but it&#39;s another place for knowledge to be splintered. We also have a Discourse forum, which I prefer, but the types of conversations people are willing to have there are not the most interesting.</p>
<p>All of this is a massive problem, especially now that we have all these language models that rely on having a large corpus of available text to train on. A lot of our question-answer code is locked away in a Slack history we&#39;ll never see, and that&#39;s made it harder for language models to help us write good Julia code.</p>
<p><strong>People have decided that Python is fine, and it kind of is.</strong> Look. I hate Python. If you&#39;re reading this blog or know of me, you may know this about me. It&#39;s a bad language that&#39;s had an endless amount of shit piled on top of it. I don&#39;t like a lot of the language decisions, the package management, etc. Lots of points for me to get irrationally angry about.</p>
<p>However.</p>
<p>Python is approachable. And it is such a terrible language by itself, but it is an <strong>incredible</strong> glue language. Most of what people use Python for these days has very little to do with Python. It&#39;s all just calling out to code written in C&#43;&#43; or whatever, and slapping this easy-to-read syntax on top of it. This works really well for python, because you can have hardo-numeric-engineer types go write big crazy stuff and then have users who just want to push a button and make a neural net go.</p>
<p>Ultimately, this is what you want a lot of computing to be – easy. If you are a user you don&#39;t want to think about the bajillion person-hours that went into making Pytorch work, because it is a miracle of modern computing. You want buttons and magic and Python gives you that. We can all just settle for Python and be fine with it. Lots of people love Python, it works for them, and it gives you access to the largest ecosystem of high-quality code in the history of computing.</p>
<p>Julia <em>can</em> give you this, but it is harder. There&#39;s just not been the resources to make this kind of thing available. Python has been pulling ahead of basically everything for as long as I can remember. More use, more funds, more use, more funds, the loop continues. Julia, even though it <em>can</em> do all the things that Python &#43; good languages can do, it would take a lot of work to get there. It is very hard to compete with Python.</p>
<p>In some sense this is also due in part because Julia is a great numerical computing language, which is what people also tend to use Python for. People in Python often want quick shit hacked out, as Julia people also often want. Other languages like Rust are so incredibly different from Python in that they provide something Python simply can&#39;t. In the case of rust, this is an inordiately powerful compiler that can give you a lot of guarantees about how your program will run even before you run it. It&#39;s a fantastic systems language. Python has been used for a lot of systems programming but this is honestly not something I think Python will ever be good at – use Rust instead.</p>
<p>Julia is closer to Python than it is to Rust, and so it might ultimately end up never really getting anywhere near Python.</p>
<p><strong>And that&#39;s fine with me.</strong> </p>
<p>I love Julia, and I&#39;m going to keep working in it, and I&#39;m going to enjoy it. Because it is <em>beautiful</em> and challening and interesting. Because the people are all really lovely. Because I want to see what it can do&#33; And maybe if I keep talking about it and showing people, maybe they&#39;ll love it as much as I do. I just think that&#39;d be a really lovely thing to share with you all.</p>
<p>Anyways, thanks for reading. Email me your favorite Julia shit at <a href="mailto:cameron@pfiffer.org">cameron@pfiffer.org</a>.</p>
<p>Cameron</p>
<div class=page-foot >
    Cameron Pfiffer. Last modified: April 13, 2024.
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
</div>
</div>
    
    
        <script src="/libs/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>