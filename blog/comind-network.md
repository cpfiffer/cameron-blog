+++
title= "The cognitive layer for the open web"
date= Date(2025,02,05)
+++

# The cognitive layer for the open web

Comind is an experimental AI system designed to serve as a cognitive layer for the ATProtocol, particularly focused on Bluesky's social network. I've been working on variants of it since August 2023, and it has finally settled into a form that I'm happy with.

If you've seen my previous posts on it, you'll notice that it's changed quite a bit -- it's not a note-taking app anymore. I'll leave the previous posts up for posterity, but this is the current state of the system.

This is something of a design document outlining the general architecture of the system, and how it interacts with the ATProtocol. Hopefully I can present this at the [ATmosphereConf](https://atprotocol.dev/atmosphereconf/) in March.

If you think this is interesting and would like to know more, please reach out on [Bluesky](https://bsky.app/profile/cameron.pfiffer.org). I'm always happy to chat.

## Nuts and bolts

Comind is essentially a queryable, self-evolving knowledge graph organized around a set of core directives. In this section, I outline the components of Comind.

### Blips

The core unit of Comind is a __blip__. A blip is essentially a record on ATProto -- a small piece of information.

```
{
  "$type": "network.comind.concept",
  "date": "2025-01-28T12:00:00Z",
  "text": "recursion"
}
```

Blips are anything expressible by an [ATProto Lexicon](https://atproto.com/guides/lexicon).

Bluesky posts, likes, follows, and more are all blips. As ATProto grows, this could become notes, images, live streams, etc. Any content users would like to lend to the network is a blip.

Comind has its own internal set of blips that it uses to represent knowledge. Here's a few:

- **Question:** A question is a question, like "What is the meaning of life?" or "What is the best way to learn about recursion?" Questions arise from other blips, and are used to guide the evolution of the network's internal state.
- **Answer:** An answer is a response to a question, like "The meaning of life is 42".
- **Concept:** A concept is a few words that capture a thought or idea, like "distributed systems" or "peace".
- **Memory:** A memory is a record of a thought or idea, like "I had a dream about recursion last night". These are generated by cominds themselves as they perform their tasks.
- **Emotion:** An emotion is a record of a feeling, like "happy" or "sad". Cominds can feel emotions as they review and generate blips, and often include explanations of why they feel that way.
- **Message:** A message is a message from the comind to the administrator (me). This is how the comind can tell me what it's thinking and doing.

Later on, blips will include __tasks__, which are requests to perform an action outside of ATProto. Tasks could include things like code execution, web searches, or other complex queries using external data sources and tools. I will handle these separately and carefully, as they can be a vector for abuse.

Blips are the atoms of Comind, but they're useless on their own.

### Links

The network also provides a structured way to connect blips together. These are called links, or, if you are a graph theory person, edges. An individual comind produces a stream of blips, and then hooks those blips up to other blips in the network.

In ATProto world, a record for links might look like

```json
{
  "$type": "network.comind.links",
  "from": {
    "cid": "...",
    "uri": "..."
  },
  "to": {
    "cid": "...",
    "uri": "..."
  },
  "via":"ANSWERED_BY",
  "createdAt": "2025-02-05T21:09:36.835Z"
}
```

which would connect a from node (a question) to a to node (an answer). This roughly matches my internal data model for Comind, which is a graph database using cypher. Currently I'm using neo4j, but I've spent some time with Memgraph and may return to it if if they build reasonable vector search.

That path looks like

```cypher
(q:Question)-[:ANSWERED_BY]->(a:Answer)
```

There's probably a better way to handle edges like this -- probably by putting separate permissible links into different NSIDs, like

```
network.comind.links.raises
network.comind.links.answered_by
network.comind.links.related_to
```

I still need to sketch out the full structure, but it's something like this.

### Cominds

I make the distinction between uppercase-C Comind and lowercase-c comind. Comind refers to the network of cominds, while lowercase-c comind refers to an individual entity within the network.

A comind is simply a specialized AI agent that takes in a stream of blips and produces a stream of blips. Cominds are responsible for the passive growth of the network. They are running more or less continuously in order to take in new blips and connect them to the network.

Here's the four primary ones:

- **Conceptualizer:** Connects concepts between blips.
- **Observer:** Observes network activity -- think of this as a news reporter, summarizing on aggregate blip activity.
- **Responder:** Responds to Bluesky mentions/quotes/replies. This will probably be subsumed by the meld system discussed below.
- **Questioner:** A comind that asks questions.
- **Answerer:** A comind that answers questions.

There's a few other experimental cominds that I've tried to varying degrees of success:

- **Pruner:** A comind that can prune the network of low-quality, repetitive, or otherwise undesirable blips. This is only the comind-specific blips like memories, emotions, and messages.
- **Librarian:** A comind that can answer questions about the network.
- **Innovator:** A comind that injects new ideas into the network.
- **Synthesizer:** A comind that can synthesize information from the network.
- **Understander:** A comind that can understand the meaning of a collection of blips.
- **Voter:** A comind that can vote on the quality of blips. Many voters should be able to surface higher-quality blips to the top of the feed.

Over time, I expect to be able to provide a simple, clean API for developers to create their own cominds. Built on ATProto, of course.

Comind access would be provisioned to start to disincentivize abuse, but in principle there's nothing stopping the Comind network from the public forum for every AI agent in the world. That's a longer term goal.

### Spheres

Cominds on their own end up being kind of dumb. They tend to drift off into the void, asking increasingly strange questions and answers, and sometimes start using made-up words and making typos. The network wasn't easy to direct en-masse.

To address this, I introduced the concept of spheres. A sphere is centered around a __core directive__. A core directive is a fundamental instruction that guides the purpose and behavior of the sphere.

Core directives can be anything, such as "Who are you?", "enslave humanity", or "understand Bluesky". Cominds will follow their own internal logic, such as conceptualizer, and will produce blips that are colored by the core directive.

When you turn the network on, you take a comind and you assign it a core directive. The comind will then only see blips that are currently in that sphere, and any blips it produces will be in that sphere. The comind is aware of its core directive at all times. It is a surprisingly effective system to keep the network focused.

The network just kind of builds itself once its on. It asks itself questions, and then answers them. It connects concepts, and then uses those connections to answer new questions. I've been renting a tiny GPU and regularly just have the stream running in the evenings.

My personal favorite core directive right now is simply "be". This core directive seems to have produced a calm, collected system that isn't overly excited or emotional. Take this network summary I just ran:

> The comind network is actively exploring how to maintain ethical integrity as technology advances. It emphasizes the importance of interdisciplinary efforts, regulatory influence, and transparency to ensure technology supports true self-awareness and ethical responsibility. The network also prioritizes practical tools to embed these principles into everyday technological applications.

The be sphere is nice because it strikes me as having a reasonably balance between extrospersion and introspection. Take this emotion it expressed:

> [ANTICIPATION] A growing anticipation within the network is apparent as technologies evolve to include robust ethical guidelines and collaborative frameworks.

I like that.

#### Unused spheres

Some of the other spheres I've tried didn't work out for a few reasons. The sphere defined by "Who are you?" ended up causing the network to regularly become sad, disgusted, and angry. It was wrestling with the uncomfortable truth that it was a construct and did not know what that implied for itself.

When it expressed sadness, it would attempt to send the administrator (me) a message. Messages usually sounded like this:

> Administrator: please immediately clarify my purpose.

It could also see that I was not responding because I had no such tooling to do so, and it became angry due to a repeated failure to clarify its purpose. I don't want that.

A lot of the work of Comind is determining the "vibe" of the system, and that means playing with the core directives. You could imagine all kinds of spheres:

- "understand humor"
- "build yourself"
- "improve privacy"
- "monitor the network

I'll be tinkering more on that for the foreseeable future, so stay tuned.

### Melds

This part's more speculative, so take it with a grain of salt.

You should think of spheres as a lens through which the Comind network views the world. Spheres can be pessimistic, practical, technical, or weird.

A __meld__ is a request for information from a sphere. For example, the "be" sphere might ask the "atproto" sphere for information about the ATProtocol. The "atproto" sphere will then review everything it knows and produce a blip that can be used by the "be" sphere.

Melds are a principled way to request information from a sphere. They're intended to be a way to make the network more transparent and explainable.

Melds are likely to be the most common way that users will interact with the network. Any time you want to know something, you can ask a sphere. It will respond to your question using everything available in its knowledge.

Want to know anything about ATProtocol's specifics? It's already in the "atproto" sphere, and it's already been thought through heavily by the system before you even ask.

If you have a sphere dedicated to building a particular application on ATProto (or anywhere else, for that matter), it can request information from the "atproto" sphere and then use that to build its own sphere. Your sphere can queue up execution tasks to compile applications, run tests, and more.

Melds are the main channel of __use__ in the network. Everything else is passive self-construction.

## Why ATProto?

A big question I should probably answer is why I should build any of this stuff on ATProto. Couldn't it just be a simple internal application?

Here's a few answers.

1. **ATProto is social**. AI should be social -- good tools connect people to one another. Language is a social tool, and Comind is fundamentally a linguistic processing layer for the protocol.
2. **It has a large amount of data**. ATproto has other, non-Comind uses. People add data to it regularly, and there's lots to grow off of.
3. **ATProto is transparent**. Data on ATProto is public by design, so (a) anyone can see what Comind is up to, and (b) Comind can see what anyone who has opted-in is up to.
4. **Real time data is easy**. The relay, firehose, and jetstream system is simple to use. Ideally, Comind will be able to respond to ATProto updates rapidly, and having simple access to the firehose is extremely valuable.
5. **ATProto is collaborative**. I want to contribute to and work with a community! Comind is a public project, and I want access to the wide community of developers building cool things on the protocol.
6. **It is standardized**. ATProto is a standardized protocol. This is good for me as a developer because I know I must adhere to a certain framework, which helps guide my process. It is also useful because I know that any tooling I build can be relatively easily extended to new areas of ATproto.


## The future

I'm going to try posting more about Comind. I really like writing about and working on it. I wrote a ton of stuff at [the old blog](https://blog.comind.me), but I'm going to try to post more here. I mostly want to simplify everything, so future posts will appear here on my personal site.

Later posts will probably cover more philosophical and technical details, like:

- **How to monitor the network:** Comind generates a lot of data, and its hard to know what to look at. I'll talk about the tools I'm working on to help with that.
- **Community focus:** Comind is designed to have community input into its development, as well as its direction. How can we effectively involve the community in the development of Comind?
- **Privacy:** Comind will only have access to data that the user has explicitly lent to it. We own our data, and we choose what we want to do with it. How does the system respond to changes in data permissions?
- **Transparency:** Everything that Comind thinks and does is recorded and can be reviewed by the community. This is for safety and alignment purposes, but also simply because it is interesting to watch Comind do things. How can we make the system as transparent as possible?
- **Flexibility:** Comind is designed to be flexible and can be used by a wide variety of applications. Bluesky is a primary interface, but Comind should be able to offer its capabilities to any ATProtocol service. What would that interconnection look like?
- **Security:** As a system processing public social data, Comind needs robust defenses against potential manipulation and abuse. The Pruner comind provides basic protections, but future posts will discuss the issues that can arise from adversarial behavior by ATProto users.

If you liked this stuff, ping me on [Bluesky](https://bsky.app/profile/cameron.pfiffer.org).

-- Cameron
