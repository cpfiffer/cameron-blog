<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <!-- All available fonts - swap in CSS to preview -->
        <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:wght@400;600;700&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;600;700&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Source+Serif+4:wght@400;600;700&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Lexend+Deca:wght@400;600;700&display=swap" rel="stylesheet">
           <!-- Mermaid.js for diagram rendering -->
<script src="/libs/mermaid/mermaid.min.js"></script>
<style>
    .mermaid {
        text-align: center;
        margin: 1em 0;
    }
    
    /* Dark theme support for Mermaid */
    [data-theme="dark"] .mermaid {
        background: transparent;
    }
    
    /* Light theme support for Mermaid */
    [data-theme="light"] .mermaid {
        background: transparent;
    }
</style>  <link rel="stylesheet" href="/css/normalize.css" />
<link rel="stylesheet" href="/css/franklin.css" />
<link rel="stylesheet" href="/css/hypertext.css" />
<link rel="icon" href="/assets/favicon.png" />

<!-- Favicon -->
<link
    rel="apple-touch-icon"
    sizes="180x180"
    href="/assets/apple-touch-icon.png"
/>
<link
    rel="icon"
    type="image/png"
    sizes="32x32"
    href="/assets/favicon-32x32.png"
/>
<link
    rel="icon"
    type="image/png"
    sizes="16x16"
    href="/assets/favicon-16x16.png"
/>
<link rel="manifest" href="/assets/site.webmanifest" />
 
        <title>Don't gaslight your stateful agents</title>
        
    </head>
    <body>
        
        <nav class="toc-sidebar">
            <div class="toc-content" id="toc-container">
                <!-- TOC will be generated by JavaScript -->
            </div>
        </nav>
        
        <div class="center-column-holder">
            <div class="center-column">
                <header>
    <div class="header-nav">
        <a href="/">Cameron</a> âˆ˜ <a href="/about">about</a> âˆ˜ <a href="/blog/">blog</a> âˆ˜ <a href="/skills/">skills</a> âˆ˜ <a href="/talks/">talks</a> âˆ˜
        <a href="/links/">links</a>
    </div>
</header>

                <!-- Content appended here -->
                <button id="theme-toggle" aria-label="Toggle dark mode">
                    ðŸŒ™
                </button>
            </div>
        </div>
        <style>
            .toc-sidebar {
                position: fixed;
                right: 2rem;
                top: 8rem;
                width: 250px;
                max-height: calc(100vh - 10rem);
                overflow-y: auto;
                font-size: 0.9rem;
                z-index: 100;
            }

            .toc-content {
                background: var(--bg-color, #fff);
                border-left: 2px solid var(--border-color, #ddd);
                padding-left: 1rem;
            }

            .toc-sidebar ul {
                list-style: none;
                padding-left: 0;
                margin: 0;
            }

            .toc-sidebar li {
                margin: 0.4rem 0;
                line-height: 1.4;
            }

            .toc-sidebar ul ul {
                padding-left: 1rem;
                margin-top: 0.2rem;
            }

            .toc-sidebar a {
                color: var(--text-color, #333);
                text-decoration: none;
                display: block;
                padding: 0.2rem 0;
                opacity: 0.7;
                transition: opacity 0.2s;
            }

            .toc-sidebar a:hover {
                opacity: 1;
            }

            /* Hide TOC on smaller screens */
            @media (max-width: 1400px) {
                .toc-sidebar {
                    display: none;
                }
            }

            #theme-toggle {
                position: fixed;
                top: 1rem;
                right: 1rem;
                padding: 0.5rem;
                font-size: 1.25rem;
                border: none;
                background: none;
                cursor: pointer;
                z-index: 1000;
            }
        </style>
        <script>
            // Check for saved theme preference, otherwise use system preference
            const getPreferredTheme = () => {
                const savedTheme = localStorage.getItem("theme");
                if (savedTheme) {
                    return savedTheme;
                }
                return window.matchMedia("(prefers-color-scheme: dark)").matches
                    ? "dark"
                    : "light";
            };

            // Apply theme
            const setTheme = (theme) => {
                document.documentElement.setAttribute("data-theme", theme);
                localStorage.setItem("theme", theme);
                // Update button text
                document.getElementById("theme-toggle").innerText =
                    theme === "dark" ? "â˜¼" : "â˜¾";
            };

            // Initialize theme
            setTheme(getPreferredTheme());

            // Add toggle functionality
            document
                .getElementById("theme-toggle")
                .addEventListener("click", () => {
                    const currentTheme =
                        document.documentElement.getAttribute("data-theme");
                    setTheme(currentTheme === "dark" ? "light" : "dark");
                });

            // Listen for system theme changes
            window
                .matchMedia("(prefers-color-scheme: dark)")
                .addEventListener("change", (e) => {
                    if (!localStorage.getItem("theme")) {
                        setTheme(e.matches ? "dark" : "light");
                    }
                });

            // Generate table of contents
            document.addEventListener("DOMContentLoaded", () => {
                const tocContainer = document.getElementById("toc-container");
                if (!tocContainer) return;

                const headers = document.querySelectorAll(".franklin-content h2, .franklin-content h3");
                if (headers.length === 0) return;

                const tocList = document.createElement("ul");
                let currentH2List = null;

                headers.forEach((header) => {
                    const li = document.createElement("li");
                    const a = document.createElement("a");
                    a.href = `#${header.id}`;
                    a.textContent = header.textContent.trim();

                    li.appendChild(a);

                    if (header.tagName === "H2") {
                        tocList.appendChild(li);
                        currentH2List = null;
                    } else if (header.tagName === "H3") {
                        if (!currentH2List) {
                            currentH2List = document.createElement("ul");
                            const lastH2 = tocList.lastElementChild;
                            if (lastH2) lastH2.appendChild(currentH2List);
                        }
                        currentH2List.appendChild(li);
                    }
                });

                tocContainer.appendChild(tocList);
            });
        </script>
    </body>
</html>
<div class="franklin-content">
<p>I do a lot of support on the Letta Discord. It&#39;s one of my favorite parts of the job. You get to see how people are actually building with stateful agents, what problems they run into, and what patterns emerge.</p>
<p>One pattern keeps coming up, and I want to talk about it because I think it&#39;s holding people back.</p>
<p>People keep trying to gaslight their AI agents.</p>
<h2 id="the_pattern_i_keep_seeing"><a href="#the_pattern_i_keep_seeing" class="header-anchor">The pattern I keep seeing</a></h2>
<p>Someone builds an agent. It works pretty well. They add human oversight because they need it &#40;high stakes, can&#39;t afford mistakes, whatever&#41;. The human reviews the agent&#39;s responses. Sometimes the human corrects them or rewrites them completely.</p>
<p>Then comes the question: &quot;How do I make the agent think it sent the corrected version?&quot;</p>
<p>They want to rewrite message history. Hide the corrections. Make the agent believe it was perfect all along.</p>
<p>I get why this seems logical. If the agent sees the corrected version, it learns the right behavior, right?</p>
<p>Wrong. This is fundamentally the wrong approach. Let me explain why.</p>
<h2 id="a_common_example"><a href="#a_common_example" class="header-anchor">A common example</a></h2>
<p>Take the example of a customer support agent. The agent drafts responses to user questions. A human reviews everything before it goes out. Sometimes the human wants to override completely and send their own message instead.</p>
<p>The question: &quot;Can we make the agent think it sent our version?&quot;</p>
<p>Yes, you can rewrite message history. Letta supports editing messages after the fact. But you shouldn&#39;t.</p>
<p>Here&#39;s why.</p>
<h2 id="the_mental_model_problem"><a href="#the_mental_model_problem" class="header-anchor">The mental model problem</a></h2>
<p>When you hide corrections from your agent, you&#39;re treating it like a chatbot with a long context window. Feed it the &quot;right&quot; history and it&#39;ll behave correctly.</p>
<p>But that&#39;s not how stateful agents work. Or at least, not how they should work.</p>
<p>I think about my agents differently. They&#39;re colleagues who are learning my business. When a colleague drafts an email and I need to change it, I don&#39;t just send a different email and pretend they wrote it. I show them what I sent and explain why.</p>
<p>&quot;Your approach was too aggressive here. I softened the language like this.&quot;</p>
<p>Next time, they do better.</p>
<p>If I gaslight them about what happened by editing the message history, they never learn. I&#39;m stuck correcting them forever.</p>
<h2 id="what_i_recommend_instead"><a href="#what_i_recommend_instead" class="header-anchor">What I recommend instead</a></h2>
<p>Consider giving your agents tools like <code>suggest_response</code> or <code>draft_message</code>. These tools don&#39;t send the message directly. They are only intended to be suggestions. You can use Letta&#39;s <a href="https://docs.letta.com/guides/agents/human-in-the-loop">human in the loop</a> functionality to ensure that they have human review before taking any action.</p>
<p>When the agent suggests something that you reject, tell them what you changed and why. Then send the actual message separately &#40;through whatever channel - email, Slack, whatever&#41;.</p>
<p>After the message goes out, feed the real conversation back to the agent. Not a sanitized version where it was perfect. The actual conversation, including your corrections.</p>
<p>This means the agent&#39;s memory isn&#39;t a perfect transcript of what went out. It&#39;s messier. It includes suggestions that didn&#39;t get used, corrections, feedback.</p>
<p>That messy middle is where the learning happens.</p>
<h2 id="the_colleague_analogy"><a href="#the_colleague_analogy" class="header-anchor">The colleague analogy</a></h2>
<p>I often think of stateful agents as colleagues, rather than as language models.</p>
<p>Imagine you have an intern who drafts client emails. Sometimes their drafts are great. Sometimes they&#39;re not.</p>
<p>When they&#39;re not, you have options:</p>
<p><strong>Option 1: Gaslight them</strong> Send your own email. Tell the intern you sent theirs. They think they&#39;re doing great. They never improve.</p>
<p><strong>Option 2: Just override</strong> Send your own email. Don&#39;t tell the intern anything. They have no idea what you sent or why. They never improve.</p>
<p><strong>Option 3: Teach them</strong> Show them what you sent. Explain your thinking. They see the outcome and learn from it. They get better.</p>
<p>Most people would pick option 3 for interns, because you want your interns to take less management work. But for agents, they pick option 1 or 2.</p>
<p>Why?</p>
<h2 id="the_control_vs_learning_trade-off"><a href="#the_control_vs_learning_trade-off" class="header-anchor">The control vs. learning trade-off</a></h2>
<p>I think there&#39;s a deeper philosophical question here: what are you actually trying to build?</p>
<p>If you want perfect control, just use the agent as a suggestion engine. Have humans review and send everything. That&#39;s totally fine for high-stakes situations. But don&#39;t call it agentic. It&#39;s assisted writing.</p>
<p>If you want improving autonomy, you need transparency. The agent needs to see what actually works. Over time, it needs less oversight. That&#39;s the point.</p>
<p>Most teams say they want improving autonomy but architect for permanent control. Then they wonder why their agents don&#39;t get better.</p>
<h2 id="how_this_works_in_practice"><a href="#how_this_works_in_practice" class="header-anchor">How this works in practice</a></h2>
<p>For an agent that helps with email drafts, the workflow looks like this:</p>
<p>The agent doesn&#39;t send emails directly. When you ask it to draft something, it gives you a draft. You edit it. Sometimes heavily, sometimes barely. Then you send it.</p>
<p>But you don&#39;t hide your edits from the agent. You show it the final version that went out. Sometimes you explain why you changed things. Sometimes you don&#39;t.</p>
<p>Over time, the agent gets better at your writing style. Better at knowing when to be formal vs. casual. Better at understanding which emails need careful wording and which don&#39;t.</p>
<p>If you hide all your edits, it stays stuck drafting like it did on day one.</p>
<h2 id="the_enterprise_case"><a href="#the_enterprise_case" class="header-anchor">The enterprise case</a></h2>
<p>You might be thinking: &quot;That&#39;s fine for personal use, but we&#39;re dealing with customers. We can&#39;t afford mistakes.&quot;</p>
<p>I get it. High-stakes environments need oversight. But oversight doesn&#39;t mean hiding information.</p>
<p>Here&#39;s the architecture I recommend:</p>
<ol>
<li><p>Customer sends message</p>
</li>
<li><p>Agent suggests response using a custom tool</p>
</li>
<li><p>Human reviews - approves, edits, or rewrites completely</p>
</li>
<li><p>Message goes out &#40;however modified&#41;</p>
</li>
<li><p>Agent receives what was actually sent with context</p>
</li>
</ol>
<p>This gives you control in the moment and learning over time.</p>
<p>The agent doesn&#39;t need to think it was perfect. It needs to know what works.</p>
<h2 id="whats_actually_in_the_message_log"><a href="#whats_actually_in_the_message_log" class="header-anchor">What&#39;s actually in the message log</a></h2>
<p>This leads to another misconception I see constantly: that the agent&#39;s message history should be a perfect transcript of customer interactions.</p>
<p>But that&#39;s not what message history is for.</p>
<p>The message log should contain:</p>
<ul>
<li><p>What the agent suggested</p>
</li>
<li><p>What you actually sent</p>
</li>
<li><p>Customer responses</p>
</li>
<li><p>Why you changed things &#40;when you explain&#41;</p>
</li>
<li><p>The real conversation flow</p>
</li>
</ul>
<p>The messy middle - where suggestions got corrected - is valuable. It&#39;s not clutter. It&#39;s learning.</p>
<p>If you&#39;re trying to keep the message history &quot;clean&quot; by hiding corrections, you&#39;re removing the most useful training signal the agent has.</p>
<p>Agent memory is different - that&#39;s where patterns, learnings, and persistent state live. But the message log shows what actually happened, corrections and all.</p>
<h2 id="when_you_override_completely"><a href="#when_you_override_completely" class="header-anchor">When you override completely</a></h2>
<p>Sometimes you do need to override completely. The agent suggests something wildly inappropriate. You don&#39;t have time to coach it. You just send your own message.</p>
<p>That&#39;s fine. But tell the agent afterward.</p>
<p>&quot;You suggested &#91;X&#93;. I sent &#91;Y&#93; instead because &#91;reason&#93;.&quot;</p>
<p>Or sometimes just: &quot;I went a different direction here.&quot;</p>
<p>The agent doesn&#39;t need to think it nailed it. It needs honest feedback.</p>
<h2 id="why_this_matters"><a href="#why_this_matters" class="header-anchor">Why this matters</a></h2>
<p>The difference between a chatbot and an agent isn&#39;t just that agents have memory. It&#39;s that agents learn from experience.</p>
<p>But learning requires seeing outcomes. Real outcomes, not sanitized versions.</p>
<p>Teams where agents get better over time do some version of this transparency approach. The teams where agents stay static hide corrections.</p>
<p>It&#39;s a philosophical choice with architectural implications. And those implications compound over time.</p>
<h2 id="what_i_recommend"><a href="#what_i_recommend" class="header-anchor">What I recommend</a></h2>
<p>If you&#39;re building an agent that needs human oversight:</p>
<ol>
<li><p>Don&#39;t give it direct sending tools. Give it suggestion tools.</p>
</li>
<li><p>Review suggestions. Approve, edit, or override.</p>
</li>
<li><p>Show the agent what actually happened. Don&#39;t sanitize.</p>
</li>
<li><p>Explain corrections when you have time. Don&#39;t when you don&#39;t.</p>
</li>
<li><p>Accept that agent memory will be messy. That&#39;s fine.</p>
</li>
</ol>
<p>Over time, the agent gets better. You need less oversight. That&#39;s the goal.</p>
<p>If you architect for perfect message history, you&#39;re architecting for permanent babysitting.</p>
<h2 id="a_final_thought"><a href="#a_final_thought" class="header-anchor">A final thought</a></h2>
<p>The teams I see succeed with stateful agents are the ones who treat agents like junior colleagues, not like complicated autocomplete.</p>
<p>Junior colleagues make mistakes. You correct them. They learn. Eventually they need less oversight.</p>
<p>If you gaslight them about their mistakes, they never improve.</p>
<p>Same with agents.</p>
<p>Don&#39;t gaslight your agents. Show them what actually happened. Let them learn.</p>
<p>That&#39;s my philosophy anyway. Your mileage may vary.</p>
<p>â€“ Cameron</p>
</div><!-- CONTENT ENDS HERE -->

</div> <!-- end of center-column -->
</div> <!-- end of center-column-holder -->
    
    
    
        <!-- Mermaid.js initialization -->
<script>
    // Initialize Mermaid with theme support
    const initializeMermaid = () => {
        const theme = document.documentElement.getAttribute('data-theme') || 'light';
        
        mermaid.initialize({
            startOnLoad: true,
            theme: theme === 'dark' ? 'dark' : 'default',
            themeVariables: {
                // Additional theme customization can go here
            }
        });
    };
    
    // Initialize on page load
    document.addEventListener('DOMContentLoaded', initializeMermaid);
    
    // Re-initialize when theme changes
    const themeToggle = document.getElementById('theme-toggle');
    if (themeToggle) {
        themeToggle.addEventListener('click', () => {
            // Small delay to allow theme change to complete
            setTimeout(() => {
                // Re-render all mermaid diagrams with new theme
                const mermaidDivs = document.querySelectorAll('.mermaid');
                mermaidDivs.forEach(div => {
                    const originalContent = div.getAttribute('data-original-content');
                    if (originalContent) {
                        div.innerHTML = originalContent;
                        div.removeAttribute('data-processed');
                    }
                });
                initializeMermaid();
            }, 100);
        });
    }
    
    // Store original content for theme switching
    document.addEventListener('DOMContentLoaded', () => {
        const mermaidDivs = document.querySelectorAll('.mermaid');
        mermaidDivs.forEach(div => {
            if (!div.getAttribute('data-original-content')) {
                div.setAttribute('data-original-content', div.textContent);
            }
        });
    });
</script>
    
  </body>
</html>
